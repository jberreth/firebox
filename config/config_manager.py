#!/usr/bin/env python3
"""
Firebox Configuration Manager

This utility manages environment configurations for gateways and services.
It handles merging common configs with gateway-specific settings.
"""

import os
import sys
import json
import yaml
from pathlib import Path
from typing import Dict, List, Optional, Any
from collections import defaultdict

class ConfigManager:
    """Manages environment configuration for Firebox gateways and services."""
    
    def __init__(self, config_dir: str = "/opt/firebox/config"):
        self.config_dir = Path(config_dir)
        self.common_config_file = self.config_dir / "common.env"
        self.network_config_file = self.config_dir / "network.env"
        self.gateways_dir = self.config_dir / "gateways"
        
        # Ensure directories exist
        self.gateways_dir.mkdir(exist_ok=True)

    def load_env_file(self, file_path: Path) -> Dict[str, str]:
        """Load environment variables from a .env file."""
        config = {}
        
        if not file_path.exists():
            return config
            
        with open(file_path, 'r') as f:
            for line in f:
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                    
                # Parse key=value pairs
                if '=' in line:
                    key, value = line.split('=', 1)
                    config[key.strip()] = value.strip()
                    
        return config

    def save_env_file(self, config: Dict[str, str], file_path: Path, header: str = ""):
        """Save configuration to an environment file."""
        with open(file_path, 'w') as f:
            if header:
                f.write(f"# {header}\n")
                f.write("# Generated by Firebox Configuration Manager\n\n")
            
            for key, value in sorted(config.items()):
                f.write(f"{key}={value}\n")

    def get_common_config(self) -> Dict[str, str]:
        """Load common configuration shared by all gateways."""
        return self.load_env_file(self.common_config_file)

    def get_network_config(self) -> Dict[str, str]:
        """Load network configuration."""
        return self.load_env_file(self.network_config_file)

    def get_gateway_config(self, gateway_name: str) -> Dict[str, str]:
        """Load configuration for a specific gateway."""
        gateway_file = self.gateways_dir / f"{gateway_name}.env"
        return self.load_env_file(gateway_file)

    def get_merged_config(self, gateway_name: str) -> Dict[str, str]:
        """Get merged configuration for a gateway (common + network + gateway-specific)."""
        merged = {}
        
        # Start with common configuration
        merged.update(self.get_common_config())
        
        # Add network configuration
        merged.update(self.get_network_config())
        
        # Override with gateway-specific configuration
        merged.update(self.get_gateway_config(gateway_name))
        
        return merged

    def list_gateways(self) -> List[str]:
        """List all configured gateways."""
        gateways = []
        for file_path in self.gateways_dir.glob("*.env"):
            gateways.append(file_path.stem)
        return sorted(gateways)

    def validate_gateway_config(self, gateway_name: str) -> Dict[str, List[str]]:
        """Validate gateway configuration and return any issues."""
        issues = defaultdict(list)
        config = self.get_merged_config(gateway_name)
        
        # Required fields
        required_fields = [
            'GATEWAY_NAME', 'CONTAINER_NAME', 'HTTP_PORT', 'HTTPS_PORT',
            'GATEWAY_DATA_DIR', 'MEMORY_MIN', 'MEMORY_MAX'
        ]
        
        for field in required_fields:
            if field not in config or not config[field]:
                issues['missing'].append(field)
        
        # Port validation
        port_fields = ['HTTP_PORT', 'HTTPS_PORT', 'GAN_PORT', 'TRACE_PORT', 'METRICS_PORT']
        for field in port_fields:
            if field in config:
                try:
                    port = int(config[field])
                    if port < 1 or port > 65535:
                        issues['invalid_ports'].append(f"{field}={port}")
                except ValueError:
                    issues['invalid_ports'].append(f"{field}={config[field]}")
        
        # Memory validation
        memory_fields = ['MEMORY_MIN', 'MEMORY_MAX']
        for field in memory_fields:
            if field in config:
                value = config[field]
                if not value.endswith(('m', 'g', 'M', 'G')):
                    issues['invalid_memory'].append(f"{field}={value}")
        
        # Directory validation
        dir_fields = ['GATEWAY_DATA_DIR', 'GATEWAY_LOGS_DIR', 'GATEWAY_BACKUPS_DIR']
        for field in dir_fields:
            if field in config:
                path = Path(config[field])
                if not path.is_absolute():
                    issues['invalid_paths'].append(f"{field}={config[field]}")
        
        return dict(issues)

    def generate_docker_compose_config(self, gateway_name: str) -> Dict[str, Any]:
        """Generate Docker Compose configuration for a gateway."""
        config = self.get_merged_config(gateway_name)
        
        # Extract port mappings
        ports = []
        if 'HTTP_PORT' in config:
            ports.append(f"{config['HTTP_PORT']}:8088")
        if 'HTTPS_PORT' in config:
            ports.append(f"{config['HTTPS_PORT']}:8043")
        if 'GAN_PORT' in config:
            ports.append(f"{config['GAN_PORT']}:8060")
        if 'METRICS_PORT' in config:
            ports.append(f"{config['METRICS_PORT']}:9464")
        
        # Extract volume mappings
        volumes = []
        if 'GATEWAY_DATA_DIR' in config:
            volumes.append(f"{config['GATEWAY_DATA_DIR']}:/usr/local/bin/ignition/data")
        if 'GATEWAY_LOGS_DIR' in config:
            volumes.append(f"{config['GATEWAY_LOGS_DIR']}:/usr/local/bin/ignition/logs")
        
        # Build environment variables
        environment = {}
        env_prefixes = ['IGNITION_', 'GATEWAY_', 'LOG_', 'PROMETHEUS_']
        for key, value in config.items():
            if any(key.startswith(prefix) for prefix in env_prefixes):
                environment[key] = value
        
        # Generate compose service configuration
        compose_config = {
            'image': f"{config.get('IGNITION_IMAGE', 'inductiveautomation/ignition')}:{config.get('IGNITION_VERSION', '8.1.35')}",
            'container_name': config.get('CONTAINER_NAME', f"firebox_{gateway_name.lower()}"),
            'hostname': config.get('CONTAINER_HOSTNAME', gateway_name.lower()),
            'ports': ports,
            'volumes': volumes,
            'environment': environment,
            'restart': config.get('RESTART_POLICY', 'unless-stopped'),
            'networks': [config.get('DOCKER_NETWORK', 'firebox-network')]
        }
        
        # Add resource limits if specified
        if 'MEMORY_MAX' in config or 'CPU_LIMIT' in config:
            compose_config['deploy'] = {'resources': {'limits': {}}}
            if 'MEMORY_MAX' in config:
                compose_config['deploy']['resources']['limits']['memory'] = config['MEMORY_MAX']
            if 'CPU_LIMIT' in config:
                compose_config['deploy']['resources']['limits']['cpus'] = config['CPU_LIMIT']
        
        return compose_config

    def export_gateway_configs(self, format: str = "env") -> Dict[str, str]:
        """Export all gateway configurations in specified format."""
        configs = {}
        
        for gateway_name in self.list_gateways():
            if format.lower() == "env":
                config = self.get_merged_config(gateway_name)
                env_content = []
                for key, value in sorted(config.items()):
                    env_content.append(f"{key}={value}")
                configs[gateway_name] = "\n".join(env_content)
            elif format.lower() == "json":
                configs[gateway_name] = self.get_merged_config(gateway_name)
            elif format.lower() == "docker-compose":
                configs[gateway_name] = self.generate_docker_compose_config(gateway_name)
        
        return configs

    def print_config_summary(self):
        """Print a summary of all configurations."""
        print("üî• Firebox Configuration Summary")
        print("=" * 50)
        
        # Common config summary
        common_config = self.get_common_config()
        print(f"\nüìã Common Configuration: {len(common_config)} variables")
        print(f"  Version: {common_config.get('FIREBOX_VERSION', 'Unknown')}")
        print(f"  Environment: {common_config.get('FIREBOX_ENVIRONMENT', 'Unknown')}")
        print(f"  Host IP: {common_config.get('HOST_IP', 'Unknown')}")
        
        # Network config summary
        network_config = self.get_network_config()
        print(f"\nüåê Network Configuration: {len(network_config)} variables")
        
        # Gateway configurations
        gateways = self.list_gateways()
        print(f"\nüèóÔ∏è Gateway Configurations: {len(gateways)} gateways")
        
        for gateway_name in gateways:
            config = self.get_gateway_config(gateway_name)
            merged = self.get_merged_config(gateway_name)
            issues = self.validate_gateway_config(gateway_name)
            
            status = "‚úÖ" if not any(issues.values()) else "‚ö†Ô∏è"
            print(f"  {status} {gateway_name}")
            print(f"    Description: {config.get('GATEWAY_DESCRIPTION', 'N/A')}")
            print(f"    HTTP Port: {merged.get('HTTP_PORT', 'N/A')}")
            print(f"    Environment: {config.get('GATEWAY_ENVIRONMENT', 'N/A')}")
            
            if any(issues.values()):
                for issue_type, problems in issues.items():
                    if problems:
                        print(f"    Issues ({issue_type}): {', '.join(problems)}")


def main():
    """Command-line interface for configuration management."""
    import argparse
    
    parser = argparse.ArgumentParser(description="Firebox Configuration Manager")
    parser.add_argument("--summary", action="store_true", help="Print configuration summary")
    parser.add_argument("--validate", help="Validate gateway configuration")
    parser.add_argument("--list", action="store_true", help="List all gateways")
    parser.add_argument("--export", choices=["env", "json", "docker-compose"], help="Export configurations")
    parser.add_argument("--gateway", help="Show configuration for specific gateway")
    parser.add_argument("--generate-compose", help="Generate docker-compose config for gateway")
    
    args = parser.parse_args()
    
    config_manager = ConfigManager()
    
    if args.summary:
        config_manager.print_config_summary()
    elif args.validate:
        issues = config_manager.validate_gateway_config(args.validate)
        if any(issues.values()):
            print(f"‚ùå Configuration issues for {args.validate}:")
            for issue_type, problems in issues.items():
                if problems:
                    print(f"  {issue_type}: {', '.join(problems)}")
        else:
            print(f"‚úÖ Configuration valid for {args.validate}")
    elif args.list:
        gateways = config_manager.list_gateways()
        print("Available gateways:")
        for gateway in gateways:
            print(f"  - {gateway}")
    elif args.export:
        configs = config_manager.export_gateway_configs(args.export)
        if args.export == "json":
            print(json.dumps(configs, indent=2))
        else:
            for gateway, config in configs.items():
                print(f"=== {gateway} ===")
                if args.export == "docker-compose":
                    print(yaml.dump({gateway.lower(): config}, default_flow_style=False))
                else:
                    print(config)
                print()
    elif args.gateway:
        config = config_manager.get_merged_config(args.gateway)
        print(f"Configuration for {args.gateway}:")
        for key, value in sorted(config.items()):
            print(f"  {key}={value}")
    elif args.generate_compose:
        compose_config = config_manager.generate_docker_compose_config(args.generate_compose)
        print(yaml.dump({args.generate_compose.lower(): compose_config}, default_flow_style=False))
    else:
        config_manager.print_config_summary()


if __name__ == "__main__":
    main()